var documenterSearchIndex = {"docs":
[{"location":"tutorials/ode/torus/#Torus","page":"🟢 Torus","title":"🟢 Torus","text":"","category":"section"},{"location":"tutorials/ode/torus/","page":"🟢 Torus","title":"🟢 Torus","text":"In this tutorial, we show how to cover a torus.","category":"page"},{"location":"tutorials/ode/torus/","page":"🟢 Torus","title":"🟢 Torus","text":"It is easy to encode the manifold as follows","category":"page"},{"location":"tutorials/ode/torus/","page":"🟢 Torus","title":"🟢 Torus","text":"using CairoMakie, MultiParamContinuation\nconst MPC = MultiParamContinuation\n\nfunction F(u,p)\n    x,y,z = u\n    R2 = 0.5\n    R1 = 0.8\n    return [(sqrt(x^2 + y^2) - R1)^2 + z^2 - R2^2]\nend\n\nprob = ManifoldProblem(F, [-0.05, 1.29, -0.05], nothing)","category":"page"},{"location":"tutorials/ode/torus/","page":"🟢 Torus","title":"🟢 Torus","text":"show(prob)","category":"page"},{"location":"tutorials/ode/torus/","page":"🟢 Torus","title":"🟢 Torus","text":"We now compute a covering of the manifold ","category":"page"},{"location":"tutorials/ode/torus/","page":"🟢 Torus","title":"🟢 Torus","text":"S = MPC.continuation(prob,\n            Henderson(np0 = 8),\n            CoveringPar(max_charts = 2000, \n                    max_steps = 16000,\n                    verbose = 0,\n                    R0 = .1,\n                    ϵ = Inf,\n                    delta_angle = Inf,\n                    ))\nshow(S)","category":"page"},{"location":"tutorials/ode/torus/","page":"🟢 Torus","title":"🟢 Torus","text":"You plot the result as follows","category":"page"},{"location":"tutorials/ode/torus/","page":"🟢 Torus","title":"🟢 Torus","text":"f = MPC.plotd(S; \n    draw_tangent = true, \n    draw_edges = true,\n    plot_center = false,\n    ind_plot = [1,3])","category":"page"},{"location":"tutorials/ode/abc/#ABC-problem","page":"🟢 ABC problem","title":"🟢 ABC problem","text":"","category":"section"},{"location":"tutorials/ode/abc/","page":"🟢 ABC problem","title":"🟢 ABC problem","text":"Pages = [\"abc.md\"]\nDepth = 3","category":"page"},{"location":"tutorials/ode/abc/","page":"🟢 ABC problem","title":"🟢 ABC problem","text":"The goal of this tutorial is to show how to compute a Manifold from a BifurcationProblem as function of two free parameters.","category":"page"},{"location":"tutorials/ode/abc/","page":"🟢 ABC problem","title":"🟢 ABC problem","text":"using Revise, CairoMakie\nusing BifurcationKit, MultiParamContinuation\n\nconst BK = BifurcationKit\nconst MPC = MultiParamContinuation\n\nfunction abc!(dz, z, p, t = 0)\n    (;D, B, σ, β, α) = p\n    u1, u2, u3 = z\n    dz[1] = -u1 + D*(1 - u1)*exp(u3)\n    dz[2] = -u2 + D*(1 - u1)*exp(u3) - D*σ*u2*exp(u3)\n    dz[3] = -u3 - β*u3 + D*B*(1 - u1)*exp(u3) + D*B*α*σ*u2*exp(u3)\n    dz\nend\n\n# we group the differentials together\npar_abc = (D = 0.11, B = 8., α = 1., σ = 0.04, β = 1.56)\nz0 = [1., 0., 0. ]\nprob_bk = BifurcationProblem(abc!, z0, par_abc, (@optic _.D), \n        record_from_solution = (x, p; k...) -> (u3 = x[3], u1 = x[1], u2 = x[2]),)\n\nopts_br = ContinuationPar(p_max = .5, n_inversion = 8, nev = 3)\nbr = BK.continuation(prob_bk, PALC(), opts_br; normC = norminf)\n\nfig, ax = BK.plot(br, plotfold=false, )\nfig","category":"page"},{"location":"tutorials/ode/abc/","page":"🟢 ABC problem","title":"🟢 ABC problem","text":"We can also compute the stationary points as function of two free parameters:","category":"page"},{"location":"tutorials/ode/abc/","page":"🟢 ABC problem","title":"🟢 ABC problem","text":"prob = MPC.ManifoldProblem_BK(\n                        prob_bk, br.sol[1].x, (@optic _.D), (@optic _.β);\n                        record_from_solution = (X, p; k...) -> begin\n                            return (β = X[end], D = X[end-1], u3 = X[3])\n                        end,\n                        finalize_solution = (X,p) -> begin\n                            D = X[end-1]\n                            β = X[end]\n                            keep = (0.01 <= D <= 0.5) && (1.5 <= β <= 1.65)\n                            return keep\n                        end,\n                        )\n\nS_eq = @time MPC.continuation(prob,\n                        Henderson(np0 = 3,\n                                    θmin = 0.001,\n                                    # use_curvature = true,\n                                    use_tree = true,\n                                  ),\n                        CoveringPar(max_charts = 20000,\n                                max_steps = 1000,\n                                verbose = 0,\n                                newton_options = NewtonPar(tol = 1e-10, verbose = false),\n                                R0 = .04,\n                                ϵ = 0.1,\n                                delta_angle = 10.15,\n                                ))","category":"page"},{"location":"tutorials/ode/abc/","page":"🟢 ABC problem","title":"🟢 ABC problem","text":"You can plot the data as follows","category":"page"},{"location":"tutorials/ode/abc/","page":"🟢 ABC problem","title":"🟢 ABC problem","text":"function plot_data(S; k...)\n    fig = Figure()\n    ax = Axis3(fig[1,1], zlabel = \"u3\", xlabel = \"D\", ylabel = \"β\", title = \"$(length(S)) charts\")\n    plot_data!(ax, S; k...)\n    fig\nend\n\nfunction plot_data!(ax, S; ind_col = 1, fil=x->true, cols = [real(c.index) for c in filter(x -> fil(x.u), S.atlas)])\n    pts = mapreduce(c->[c.data[2], c.data[3], c.data[1]]', vcat, filter(x -> fil(x.u), S.atlas))\n    cols = [real(c.data[ind_col]) for c in filter(x -> fil(x.u), S.atlas)]\n    hm = scatter!(ax, pts, color = cols)\nend\n\nplot_data(S_eq)","category":"page"},{"location":"henderson/#Henderson-covering-manifold","page":"Henderson","title":"Henderson covering manifold","text":"","category":"section"},{"location":"henderson/","page":"Henderson","title":"Henderson","text":"Pages = [\"henderson.md\"]\nDepth = 3","category":"page"},{"location":"henderson/","page":"Henderson","title":"Henderson","text":"We want to approximte ","category":"page"},{"location":"henderson/","page":"Henderson","title":"Henderson","text":"mathcal M=leftu in mathbbR^n mid F(u)=0 quad F mathbbR^n rightarrow mathbbR^mright","category":"page"},{"location":"henderson/#Tangent-space-basis","page":"Henderson","title":"Tangent space basis","text":"","category":"section"},{"location":"henderson/","page":"Henderson","title":"Henderson","text":"We get an orthonormal basis of the tangent space at a space u_iinmathcal M by looking for a ntimes 2 matrix Phi_i such that ","category":"page"},{"location":"henderson/","page":"Henderson","title":"Henderson","text":"binomF_uleft(u_iright)Phi_i^T Phi_i=binom0I","category":"page"},{"location":"henderson/#Projecting-from-the-tangent-space","page":"Henderson","title":"Projecting from the tangent space","text":"","category":"section"},{"location":"henderson/","page":"Henderson","title":"Henderson","text":"A point on mathcal M corresponding to a vector s in the tangent space is solution to:","category":"page"},{"location":"henderson/","page":"Henderson","title":"Henderson","text":"beginaligned\nFleft(u_i(s)right)  =0 \nPhi_i^Tleft(u_i(s)-left(u_i+Phi_i sright)right)  =0\nendaligned","category":"page"},{"location":"henderson/","page":"Henderson","title":"Henderson","text":"Hence, u_i+Phi_i s is projected on mathcal M at the point u_i.","category":"page"},{"location":"henderson/#Algorithm","page":"Henderson","title":"Algorithm","text":"","category":"section"},{"location":"henderson/","page":"Henderson","title":"Henderson","text":"The algorithm Henderson described in [Henderson] covers a manifold mathcal M with local approximations of the manifold which are called charts. It starts with a point u_0 on mathcal M, a k-d ball B_R_0(0) on the tangent space at u_0, a convex polygon mathbb P on the tangent space. ","category":"page"},{"location":"henderson/","page":"Henderson","title":"Henderson","text":"A chart C is defined as C = (u_0B_R_0(0) mathbb P). R_0 is the radius of validity of the chart meaning that the distance of the ball (on the tangent) space to the manifold mathcal M is less than a prescribed value epsilon.","category":"page"},{"location":"henderson/","page":"Henderson","title":"Henderson","text":"The algorithm selects a set of charts (C_i)_i which covers mathcal M meaning that the union of the projection of the balls B_R_i(0) on the manifold covers (parts of) the manifold.","category":"page"},{"location":"henderson/","page":"Henderson","title":"Henderson","text":"Charts intersect if the projection of their validity balls on the manifold intersect. Their polygons are then trimmed in order to remove the intersection which can move some vertices inside the validity ball.","category":"page"},{"location":"henderson/","page":"Henderson","title":"Henderson","text":"The algorithm ends when all the charts have their polygon inside the validity ball.","category":"page"},{"location":"henderson/","page":"Henderson","title":"Henderson","text":"In the case this is not the case, the algorithm selects such a chart C = (u_0B_R_0(0) mathbb P) and define a new chart C_new by using an exterior vertex s of mathbb P. s is projected on the manifold mathcal M, its tangent space is computed, its radius is R_0 and the new polygon is the cube. The new chart C_new is then intersected with the previously computed charts.","category":"page"},{"location":"henderson/#Search-tree","page":"Henderson","title":"Search tree","text":"","category":"section"},{"location":"henderson/","page":"Henderson","title":"Henderson","text":"When the projection is very quickly computed, the limiting factor of the algorithm becomes finding the neighbors of a chart. This can become slow when the atlas is large giving a quadratic N^2 complexity in total. This can be alleviated by using a BVH tree to obtain a Nlog N complexity as explained in [Henderson]. This is implemented in MultiParamContinuation.jl and can be set up in the struct Henderson, see its associated doc.","category":"page"},{"location":"henderson/#References","page":"Henderson","title":"References","text":"","category":"section"},{"location":"henderson/","page":"Henderson","title":"Henderson","text":"[Henderson]: Henderson, Michael E. “Multiple Parameter Continuation: Computing Implicitly Defined k-Manifolds.” International Journal of Bifurcation and Chaos 12, no. 03 (March 2002): 451–76. https://doi.org/10.1142/S0218127402004498.","category":"page"},{"location":"henderson/","page":"Henderson","title":"Henderson","text":"[Dankowicz]: Dankowicz, Harry, and Frank Schilder. Recipes for Continuation. Philadelphia, PA: Society for Industrial and Applied Mathematics, 2013. https://doi.org/10.1137/1.9781611972573.","category":"page"},{"location":"library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Pages = [\"library.md\"]\nDepth = 3","category":"page"},{"location":"library/#Parameters","page":"Library","title":"Parameters","text":"","category":"section"},{"location":"library/#MultiParamContinuation.CoveringPar","page":"Library","title":"MultiParamContinuation.CoveringPar","text":"Parameters for the covering algorithm(s).\n\nFields\n\nϵ::Any: Maximum distance between the tangent plane and the manifold. Default: 0.1\nR0::Any: Initial radius of validity. Default: 0.1\nRmin::Any: [Internal] Minimal radius of polyhedra. Default: 0.001\ndelta_angle::Any: Maximum angle difference between charts' tangent spaces in radians. Default: 2π\nmax_charts::UInt64: Maximum number of charts. Default: 100\nmax_steps::UInt64: Maximum number of continuation steps. Because of mesh adaptation or failure, the number of computed charts is less or equal than max_steps. Default: 1000\nverbose::Int64: Verbose mode, belongs to {0,1,2}. verbose = 0 prints nothing. verbose = 1 prints the charts, verbose = 2 print the intersection of the charts. Default: false\nnewton_options::Any: Newton options. Default: NonLinearSolveSpec()\nsolver_bls::Any: Bordered Linear Solver Default: nothing\ndotmin::Any: [Internal]. Default: 0.2\n\n\n\n\n\n","category":"type"},{"location":"library/#Results","page":"Library","title":"Results","text":"","category":"section"},{"location":"library/#MultiParamContinuation.Chart","page":"Library","title":"MultiParamContinuation.Chart","text":"mutable struct Chart{Tu, Ttg, Tr, Tp, Tin, Td, Teve, Tl}\n\nStructure to define a chart, that is a local system of coordinates which parametrizes a small patch of the manifold.\n\nFields\n\nu::Any\nΦ::Any\nR::Any: Radius for region of validity (Ball).\nP::Any: Polyhedron. Represents the domain of the solution manifold covered by this chart.\ninside_ball::Any: Array of booleans to check if the vertices in P are inside the ball of validity\ninterior::Bool: Is the polygon inside the validity ball?\nindex::Int64\ndata::Any\nevent_values::Any\nlabel::Any\nneighbors::Vector{Int64}: [Internal] list of direct neighbors in the atlas\n\nMethods\n\ndo_intersect(c1, c2)::Bool whether the charts intersect\n\n\n\n\n\n","category":"type"},{"location":"library/#MultiParamContinuation.Atlas","page":"Library","title":"MultiParamContinuation.Atlas","text":"struct Atlas{dim, Tc, Talg, Ttree}\n\nAtlas of charts which represents a manifold.\n\nFields\n\natlas::Vector: List of Charts\nBList::Vector: [Internal] Boundary list of charts\nalg::Any: Algorithm, for example: Henderson()\ntree::Any: [Internal] Tree for neighbors search\n\nMethods\n\nadd!(a::Atlas, c::Chart)\nnew_atlas(c::Chart, alg = nothing; dim = 2)\nlength(a::Atlas) returns the number of charts\na[3] returns the 3rd chart in the atlas a, see ?Chart\n\n\n\n\n\n","category":"type"},{"location":"library/#Problems","page":"Library","title":"Problems","text":"","category":"section"},{"location":"library/#MultiParamContinuation.ManifoldProblem","page":"Library","title":"MultiParamContinuation.ManifoldProblem","text":"struct ManifoldProblem{Tu<:(AbstractVector), Tp, TVF, Trec, Tproj, Ttangent, Tradius, Tevent, Tfinalize, Tbb, Tpc, Tupdate} <: MultiParamContinuation.AbstractManifoldProblem\n\nDefine a problem to perform multi-parameters continuation of a manifold defined as the zeros of F: Rⁿ → Rᵐ with n > m >= 1.\n\nFields\n\nn::Int64: [Internal] input space dimension\nm::Int64: [Internal] output space dimension\nVF::Any: Equation representing the mapping F\nu0::AbstractVector: Guess for the initial point on the manifold\nparams::Any: Parameters passed to F\nrecordFromSolution::Any: Record a few indicators at each chart of the manifold\nproject::Any: Function to project a point from a tangent space to the manifold. If not provided, a newton algorithm is used. The signature is project(u, par) and returns a vector of solutions\nget_tangent::Any: Compute an orthonormal basis of the tangent space at a point u on the manifold. Return a matrix of dimension n x (n-m). The signature is get_tangent(u, par). If not provided, a dedicaded function is used.\nget_radius::Any: Get the an estimate of the curvature at a point u on the manifold. If not provided, a dedicaded function is used.\nevent_function::Any: Event function\nfinalize_solution::Any: Finalise solution. Function to accept or not the current chart. It has signature finalise(c::Chart, par)::Bool\nproject_for_tree::Any: Function  used to project a point for the tree used to find the charts near a new point. Needs not be linear but the dimension should be at least the manifold embedding dimension.\nprob_cons::Any: [Internal] constrained problem for projecting on manifold\nupdate!::Any: Function used to update the problem after each continuation step. The signature is update_problem!(prob, ::Atlas)\n\nConstructor\n\nManifoldProblem(F, u0, par;\n                m = length(F(u0, par)),\n                check_dim::Bool = true,\n                recordFromSolution = (u,p) -> nothing,\n                project = nothing,\n                get_radius = get_radius_default,\n                get_tangent = nothing,\n                event_function = event_default,\n                finalize_solution = finalize_default,\n                project_for_tree = project_for_tree_default\n                )\n\n\n\n\n\n","category":"type"},{"location":"library/#MultiParamContinuation.ManifoldProblemBK","page":"Library","title":"MultiParamContinuation.ManifoldProblemBK","text":"struct ManifoldProblemBK{Tu<:(AbstractVector), Tp, TVF, Trec, Tproj, Ttangent, Tradius, Tevent, Tfinalize, Tbb, Tpc, Tupdate} <: MultiParamContinuation.AbstractManifoldProblem\n\nDefine a problem to perform multi-parameters continuation of a manifold defined as the zeros of F: Rⁿ → Rᵐ with n > m >= 1.\n\nFields\n\nn::Int64: [Internal] input space dimension\nm::Int64: [Internal] output space dimension\nVF::Any: Equation representing the mapping F\nu0::AbstractVector: Guess for the initial point on the manifold\nparams::Any: Parameters passed to F\nrecordFromSolution::Any: Record a few indicators at each chart of the manifold\nproject::Any: Function to project a point from a tangent space to the manifold. If not provided, a newton algorithm is used. The signature is project(u, par) and returns a vector of solutions\nget_tangent::Any: Compute an orthonormal basis of the tangent space at a point u on the manifold. Return a matrix of dimension n x (n-m). The signature is get_tangent(u, par). If not provided, a dedicaded function is used.\nget_radius::Any: Get the an estimate of the curvature at a point u on the manifold. If not provided, a dedicaded function is used.\nevent_function::Any: Event function\nfinalize_solution::Any: Finalise solution. Function to accept or not the current chart. It has signature finalise(c::Chart, par)::Bool\nproject_for_tree::Any: Function  used to project a point for the tree used to find the charts near a new point. Needs not be linear but the dimension should be at least the manifold embedding dimension.\nprob_cons::Any: [Internal] constrained problem for projecting on manifold\nupdate!::Any: Function used to update the problem after each continuation step. The signature is update_problem!(prob, ::Atlas)\n\nConstructor\n\nManifoldProblem(F, u0, par;\n                m = length(F(u0, par)),\n                check_dim::Bool = true,\n                recordFromSolution = (u,p) -> nothing,\n                project = nothing,\n                get_radius = get_radius_default,\n                get_tangent = nothing,\n                event_function = event_default,\n                finalize_solution = finalize_default,\n                project_for_tree = project_for_tree_default\n                )\n\n\n\n\n\n","category":"type"},{"location":"library/#Continuation-algorithms","page":"Library","title":"Continuation algorithms","text":"","category":"section"},{"location":"library/#MultiParamContinuation.Henderson","page":"Library","title":"MultiParamContinuation.Henderson","text":"struct Henderson{T} <: MultiParamContinuation.AbstractCoveringAlgorithm\n\nContinuation algorithm from [1] computing implicitly defined 2d manifolds. \n\nFields\n\nnp0::Int64: Number of initial vertices in the polyhedra on each tangent space.\nuse_curvature::Bool: Use hessian for curvature estimate.\nθmax::Any: [Internal]\nθmin::Any: [Internal]\nuse_tree::Bool:  Use tree to find neighbors. Useful when the number of charts is large because the complexity changes from N² to N⋅log(N).\nchildren_pre_leaf::Int64: Number of children per leaf in the tree. Control the depth of the tree.\n\nReference(s)\n\n[1] Henderson, Michael E. “Multiple Parameter Continuation: Computing Implicitly Defined k-Manifolds.” International Journal of Bifurcation and Chaos 12, no. 03 (March 2002): 451-76. https://doi.org/10.1142/S0218127402004498.\n\n\n\n\n\n","category":"type"},{"location":"library/#Continuation-methods","page":"Library","title":"Continuation methods","text":"","category":"section"},{"location":"library/#MultiParamContinuation.step!","page":"Library","title":"MultiParamContinuation.step!","text":"step!(Ω)\n\n\nPerform one step of the continuation algorithm.\n\n\n\n\n\nstep!(Ω, n)\n\n\nPerform n steps of the continuation algorithm.\n\n\n\n\n\n","category":"function"},{"location":"library/#bouding-space","page":"Library","title":"Bounding functions","text":"","category":"section"},{"location":"library/#MultiParamContinuation.Cube","page":"Library","title":"MultiParamContinuation.Cube","text":"Define a hypercube C of radius r.\n\nC = { u ∈ Rⁿ | -r <= u <= r}\n\nYou can define one using \n\ncube = Cube(1)\n\nYou can test whether a point is in the cube by doing\n\ncube(rand(3))\n\n\n\n\n\n","category":"type"},{"location":"library/#MultiParamContinuation.ProductSpace","page":"Library","title":"MultiParamContinuation.ProductSpace","text":"struct ProductSpace{T<:(AbstractVector)}\n\nStructure to define a domain defined by a set of intervals\n\nFields\n\nlower::AbstractVector: lower parts of all intervals\nupper::AbstractVector: upper parts of all intervals\n\nUsage\n\nFor example, to create the domain [1,2] x [3,4], you can does\n\nspace = ProductSpace([1,3], [2,4])\n\nand test whether a point belongs to this space:\n\nspace(rand(2))\n\n\n\n\n\n","category":"type"},{"location":"tutorials/ode/sphereBK/#Sphere-based-on-BifurcationKit.jl","page":"🟢 Sphere based on BifurcationKit.jl","title":"🟢 Sphere based on BifurcationKit.jl","text":"","category":"section"},{"location":"tutorials/ode/sphereBK/","page":"🟢 Sphere based on BifurcationKit.jl","title":"🟢 Sphere based on BifurcationKit.jl","text":"In this tutorial, we show how to cover a sphere as solution of","category":"page"},{"location":"tutorials/ode/sphereBK/","page":"🟢 Sphere based on BifurcationKit.jl","title":"🟢 Sphere based on BifurcationKit.jl","text":"F(u) = u^2-1 = 0","category":"page"},{"location":"tutorials/ode/sphereBK/","page":"🟢 Sphere based on BifurcationKit.jl","title":"🟢 Sphere based on BifurcationKit.jl","text":"We use this model as a mean to introduce the basics of MultiParamContinuation.jl based on BifurcationKit.jl.","category":"page"},{"location":"tutorials/ode/sphereBK/","page":"🟢 Sphere based on BifurcationKit.jl","title":"🟢 Sphere based on BifurcationKit.jl","text":"It is easy to encode the manifold using ManifoldProblem_BK which yields a ManifoldProblemBK with BifurcationKit internals.","category":"page"},{"location":"tutorials/ode/sphereBK/","page":"🟢 Sphere based on BifurcationKit.jl","title":"🟢 Sphere based on BifurcationKit.jl","text":"using CairoMakie, BifurcationKit, MultiParamContinuation\nconst MPC = MultiParamContinuation\n\nF(u,p) = [u[1]^2 + u[2]^2 + u[3]^2 - 1]\n\nprob = ManifoldProblem_BK(F, \n                    [1,0.,0.],\n                    nothing\n                        )","category":"page"},{"location":"tutorials/ode/sphereBK/","page":"🟢 Sphere based on BifurcationKit.jl","title":"🟢 Sphere based on BifurcationKit.jl","text":"show(prob)","category":"page"},{"location":"tutorials/ode/sphereBK/","page":"🟢 Sphere based on BifurcationKit.jl","title":"🟢 Sphere based on BifurcationKit.jl","text":"We compute a covering of the manifold: ","category":"page"},{"location":"tutorials/ode/sphereBK/","page":"🟢 Sphere based on BifurcationKit.jl","title":"🟢 Sphere based on BifurcationKit.jl","text":"S = MPC.continuation(prob,\n            Henderson(np0 = 6),\n            CoveringPar(max_charts = 20000, \n                    max_steps = 250,\n                    # trigger the use of BifurcationKit newton solver\n                    newton_options = NewtonPar(),\n                    R0 = .2,\n                    )\n            )\nshow(S)","category":"page"},{"location":"tutorials/ode/sphereBK/","page":"🟢 Sphere based on BifurcationKit.jl","title":"🟢 Sphere based on BifurcationKit.jl","text":"You can now plot the result as","category":"page"},{"location":"tutorials/ode/sphereBK/","page":"🟢 Sphere based on BifurcationKit.jl","title":"🟢 Sphere based on BifurcationKit.jl","text":"MPC.plotd(S; \n    draw_tangent = true, \n    plot_center = false,\n    draw_edges = true,\n    ind_plot = [1,3])","category":"page"},{"location":"BifProblemBK/#Manifold-problem-for-use-with-BifurcationKit","page":"BifurcationKit","title":"Manifold problem for use with BifurcationKit","text":"","category":"section"},{"location":"BifProblemBK/","page":"BifurcationKit","title":"BifurcationKit","text":"Pages = [\"BifProblemBK.md\"]\nDepth = 3","category":"page"},{"location":"BifProblemBK/","page":"BifurcationKit","title":"BifurcationKit","text":"MultiParamContinuation.jl is based on newton algorithm which relies on NonlinearSolve.jl for the implementation. One can chose to rely on BifurcationKit.jl newton method.","category":"page"},{"location":"BifProblemBK/","page":"BifurcationKit","title":"BifurcationKit","text":"This can be done by calling ManifoldProblem_BK which has the same arguments as ManifoldProblem.","category":"page"},{"location":"tutorials/tutorials/#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"Pages = [\"tutorials.md\"]\nDepth = 2","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"The tutorials are rated by the following scale of difficulty","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"🟢 basic knowledge of (numerical) bifurcation theory (following equilibria / periodic orbits)\n🟡 advanced knowledge of (numerical) bifurcation theory (codim 2 bifurcations of equilibria)\n🟠 high level of knowledge of (numerical) bifurcation theory (codim 2 bifurcations of periodic orbits, tweaking the methods)\n🟤 very advanced tutorial, research level","category":"page"},{"location":"tutorials/tutorials/#Small-dimension-examples","page":"Tutorials","title":"Small dimension examples","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"Pages = [\"ode/plane.md\", \"ode/sphere.md\", \"ode/torus.md\",]\nDepth = 1","category":"page"},{"location":"tutorials/tutorials/#Examples-based-on-BifurcationKit","page":"Tutorials","title":"Examples based on BifurcationKit","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"Pages = [\"ode/sphereBK.md\"]\nDepth = 1","category":"page"},{"location":"tutorials/ode/sphere/#Sphere","page":"🟢 Sphere","title":"🟢 Sphere","text":"","category":"section"},{"location":"tutorials/ode/sphere/","page":"🟢 Sphere","title":"🟢 Sphere","text":"Pages = [\"sphere.md\"]\nDepth = 2","category":"page"},{"location":"tutorials/ode/sphere/","page":"🟢 Sphere","title":"🟢 Sphere","text":"In this tutorial, we show how to cover a sphere as solution of","category":"page"},{"location":"tutorials/ode/sphere/","page":"🟢 Sphere","title":"🟢 Sphere","text":"F(u) = u^2-1 = 0","category":"page"},{"location":"tutorials/ode/sphere/","page":"🟢 Sphere","title":"🟢 Sphere","text":"We use this model as a mean to introduce the basics of MultiParamContinuation.jl.","category":"page"},{"location":"tutorials/ode/sphere/","page":"🟢 Sphere","title":"🟢 Sphere","text":"It is easy to encode the manifold as follows","category":"page"},{"location":"tutorials/ode/sphere/","page":"🟢 Sphere","title":"🟢 Sphere","text":"using CairoMakie, MultiParamContinuation\nconst MPC = MultiParamContinuation\n\nF(u,p) = [u[1]^2 + u[2]^2 + u[3]^2 - 1]\n\nprob = ManifoldProblem(F, \n                    [1,0.,0.],\n                    nothing\n                        )","category":"page"},{"location":"tutorials/ode/sphere/","page":"🟢 Sphere","title":"🟢 Sphere","text":"show(prob)","category":"page"},{"location":"tutorials/ode/sphere/","page":"🟢 Sphere","title":"🟢 Sphere","text":"We now compute the covering of the manifold","category":"page"},{"location":"tutorials/ode/sphere/","page":"🟢 Sphere","title":"🟢 Sphere","text":"S = MPC.continuation(prob,\n            Henderson(),\n            CoveringPar(max_charts = 20000, \n                    max_steps = 250,\n                    verbose = 0,\n                    newton_options = NonLinearSolveSpec(;maxiters = 5),\n                    R0 = .2,\n                    )\n            )\nshow(S)","category":"page"},{"location":"tutorials/ode/sphere/","page":"🟢 Sphere","title":"🟢 Sphere","text":"You plot the result as follows","category":"page"},{"location":"tutorials/ode/sphere/","page":"🟢 Sphere","title":"🟢 Sphere","text":"MPC.plotd(S; \n    draw_tangent = true, \n    plot_center = false,\n    draw_edges = true,\n    ind_plot = [1,3])","category":"page"},{"location":"tutorials/ode/plane/#[Plane](@id-plane)","page":"🟢 Plane","title":"🟢 Plane","text":"","category":"section"},{"location":"tutorials/ode/plane/","page":"🟢 Plane","title":"🟢 Plane","text":"Pages = [\"plane.md\"]\nDepth = 3","category":"page"},{"location":"tutorials/ode/plane/","page":"🟢 Plane","title":"🟢 Plane","text":"In this tutorial, we show how to cover a plane as solution of","category":"page"},{"location":"tutorials/ode/plane/","page":"🟢 Plane","title":"🟢 Plane","text":"F(u) = u_3 = 0","category":"page"},{"location":"tutorials/ode/plane/","page":"🟢 Plane","title":"🟢 Plane","text":"We use this model as a mean to introduce the basics of MultiParamContinuation.jl.","category":"page"},{"location":"tutorials/ode/plane/","page":"🟢 Plane","title":"🟢 Plane","text":"It is easy to encode the manifold as follows","category":"page"},{"location":"tutorials/ode/plane/","page":"🟢 Plane","title":"🟢 Plane","text":"using CairoMakie, MultiParamContinuation\nconst MPC = MultiParamContinuation\n\nF(u,p) = [u[3]]\n\nprob = ManifoldProblem(F, [.0,0.,0.], nothing;\n                        # we pass a function to provide the tangent space\n                        # with an analytical formula\n                        get_tangent = (u,p) -> [1 0; 0 1; 0 0],\n                        # restrict computations to hypercube    \n                        finalize_solution = Cube(0.5)\n                        )","category":"page"},{"location":"tutorials/ode/plane/","page":"🟢 Plane","title":"🟢 Plane","text":"show(prob)","category":"page"},{"location":"tutorials/ode/plane/","page":"🟢 Plane","title":"🟢 Plane","text":"We now compute a covering of the manifold.","category":"page"},{"location":"tutorials/ode/plane/","page":"🟢 Plane","title":"🟢 Plane","text":"S = MPC.continuation(prob,\n            Henderson(np0 = 4),\n            CoveringPar(max_charts = 20000, \n                    max_steps = 100,\n                    verbose = 0,\n                    R0 = .1,\n                    ))\nshow(S)","category":"page"},{"location":"tutorials/ode/plane/","page":"🟢 Plane","title":"🟢 Plane","text":"You plot the result as follows","category":"page"},{"location":"tutorials/ode/plane/","page":"🟢 Plane","title":"🟢 Plane","text":"MPC.plotd(S; \n    draw_tangent = true, \n    plot_center = true,\n    draw_edges = true,\n    )","category":"page"},{"location":"tutorials/ode/plane/","page":"🟢 Plane","title":"🟢 Plane","text":"It is sometimes useful to have access to more information, and for example plot in 2d:","category":"page"},{"location":"tutorials/ode/plane/","page":"🟢 Plane","title":"🟢 Plane","text":"MPC.plot2d(S; \n    draw_circle = true,\n    plot_center = true,\n    put_ids = true,\n    ind_plot = [1,2])","category":"page"},{"location":"BifProblem/#Manifold-problems","page":"Manifold Problems","title":"Manifold problems","text":"","category":"section"},{"location":"BifProblem/","page":"Manifold Problems","title":"Manifold Problems","text":"Pages = [\"BifProblem.md\"]\nDepth = 3","category":"page"},{"location":"BifProblem/","page":"Manifold Problems","title":"Manifold Problems","text":"The idea behind MultiParamContinuation is to compute immersed manifolds mathcal M in memory limited environments, the manifold being defined as (parts) of the zeros of ","category":"page"},{"location":"BifProblem/","page":"Manifold Problems","title":"Manifold Problems","text":"Fmathbb R^ntimes mathbb R^partomathbb R^m","category":"page"},{"location":"BifProblem/#Generic-manifold-problem","page":"Manifold Problems","title":"Generic manifold problem","text":"","category":"section"},{"location":"BifProblem/","page":"Manifold Problems","title":"Manifold Problems","text":"ManifoldProblem is the basic / generic structure for encoding a bifurcation problem ; it holds the following fields:","category":"page"},{"location":"BifProblem/","page":"Manifold Problems","title":"Manifold Problems","text":"the vector field\nan initial guess\na set of parameters","category":"page"},{"location":"BifProblem/","page":"Manifold Problems","title":"Manifold Problems","text":"as well as user defined functions for ","category":"page"},{"location":"BifProblem/","page":"Manifold Problems","title":"Manifold Problems","text":"recording (record_from_solution) indicators about the solution when this one is too large to be saved at every continuation step.","category":"page"},{"location":"BifProblem/","page":"Manifold Problems","title":"Manifold Problems","text":"and some other that we described below. A detailed account for the struct is ManifoldProblem.","category":"page"},{"location":"BifProblem/","page":"Manifold Problems","title":"Manifold Problems","text":"tip: Tutorial\nThe Plane tutorial provides an example where these arguments are used in situation.","category":"page"},{"location":"BifProblem/#Basic-example","page":"Manifold Problems","title":"Basic example","text":"","category":"section"},{"location":"BifProblem/","page":"Manifold Problems","title":"Manifold Problems","text":"using MultiParamContinuation\n\nF(u,p) = [u[3]]\n\nprob = ManifoldProblem(F, [0,0,0.], nothing)","category":"page"},{"location":"BifProblem/#Projection-function","page":"Manifold Problems","title":"Projection function","text":"","category":"section"},{"location":"BifProblem/","page":"Manifold Problems","title":"Manifold Problems","text":"You can pass your own projection function which takes a point u_guessin mathbb R^n and project it on mathcal M. For example, in the case of the plane F(u,p) = u[3], we could use:","category":"page"},{"location":"BifProblem/","page":"Manifold Problems","title":"Manifold Problems","text":"prob = ManifoldProblem(F, [0,0,0.], nothing;\n                        project = (u_g,p) -> begin\n                        \t\tu = copy(u_g)\n                        \t\tu[3] = 0\n                        \t\treturn u\n                        end,\n                        )","category":"page"},{"location":"BifProblem/#Tangent-function","page":"Manifold Problems","title":"Tangent function","text":"","category":"section"},{"location":"BifProblem/","page":"Manifold Problems","title":"Manifold Problems","text":"You can pass your own tangent function which returns an orthonormal basis of the tangent space at point u. For example, in the case of the plane F(u,p) = u[3], we could use:","category":"page"},{"location":"BifProblem/","page":"Manifold Problems","title":"Manifold Problems","text":"prob = ManifoldProblem(F, [0,0,0.], nothing;\n                        get_tangent = (u,p) -> [1 0; 0 1; 0 0],\n                        )","category":"page"},{"location":"BifProblem/#Finalizing-the-solution","page":"Manifold Problems","title":"Finalizing the solution","text":"","category":"section"},{"location":"BifProblem/","page":"Manifold Problems","title":"Manifold Problems","text":"You can pass a finalizer function which returns a boolean. This boolean is used to discard or not the current chart. This can be used to restrict the manifold to a given bounding box.","category":"page"},{"location":"BifProblem/","page":"Manifold Problems","title":"Manifold Problems","text":"You can have a look at bounding space for predefined finalizer functions for simple spaces.","category":"page"},{"location":"BifProblem/","page":"Manifold Problems","title":"Manifold Problems","text":"prob = ManifoldProblem(F, [.0,0.,0.], nothing;\n                        finalize_solution = (c::Chart, p) -> true\n                        )","category":"page"},{"location":"plotting/#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Pages = [\"plotting.md\"]\nDepth = 3","category":"page"},{"location":"plotting/#Standard-plots-using-the-plot-recipe-from-Plots.jl","page":"Plotting","title":"Standard plots using the plot recipe from Plots.jl","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Plotting is provided by calling recipes to Plots.jl. It means that to plot a branch br, you just need to call","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"#]add Plots # You need to install Plots.jl before your first time using it!\nusing Plots\nplot(br)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"where br is a branch computed after a call to br = continuation(...). Plots can be customized using all the keyword arguments provided by Plots.jl. For example, we can change the plotting backend to the GR package and put a title on the plot by doing:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"gr()\nplot!(br, title = \"I have a branch!\")","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"or you can use a scatter plot","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"scatter(br)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Then to save the plot, use savefig, for example:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"savefig(\"myplot.png\")","category":"page"},{"location":"plotting/#Specific-plotting-keyword-arguments","page":"Plotting","title":"Specific plotting keyword arguments","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"The available arguments specific to our plotting methods are","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"plotfold = true: plot the fold points with black dots\nputspecialptlegend = true: display the legend corresponding to the bifurcation points\nvars = nothing: see below\nplotstability = true: display the stability of the branch\nplotspecialpoints = true: plot the special (bifurcation) points on the branch\nbranchlabel = \"fold branch\": assign label to a branch which is printed in the legend\nlinewidthunstable: set the linewidth for the unstable part of the branch\nlinewidthstable: set the linewidth for the stable part of the branch\nplotcirclesbif = false use circles to plot bifurcation points\napplytoX = identity apply transformation applytoX to x-axis\napplytoY = identity apply transformation applytoY to y-axis","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"If you have several branches br1, br2, you can plot them in the same figure by doing","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"plot(br1, br2)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"in place of","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"plot(br1)\nplot!(br2)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"warn: Plot of bifurcation points\nThe bifurcation points for which the bisection was successful are indicated with circles and with squares otherwise.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Note that the plot recipes use the parameter axis as xlabel, and the passed variable as ylabel.","category":"page"},{"location":"plotting/#Choosing-Variables","page":"Plotting","title":"Choosing Variables","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"You can select which variables to plot using the keyword argument vars, for example:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"plot(br, vars = (:param, :x))","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"The available symbols are :x, :param, :itnewton, :itlinear, :ds, :θ, :n_unstable, :n_imag, :stable, :step,... and:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"x if record_from_solution (see continuation) returns a Number.\nx1, x2,... if record_from_solution returns a Tuple.\nthe keys of the NamedTuple returned by record_from_solution.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"The available symbols are provided by calling propertynames(br.branch).","category":"page"},{"location":"plotting/#Plotting-bifurcation-diagrams","page":"Plotting","title":"Plotting bifurcation diagrams","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"To do this, you just need to call","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"plot(diagram)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"where diagram is a branch computed after a call to diagram = bifurcationdiagram(...). You can use the keywords provided by Plots.jl and the different backends. You can thus call scatter(diagram). In addition to the options for plotting branches (see above), there are specific arguments available for bifurcation diagrams","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"code specify the part of the bifurcation diagram to plot. For example code = (1,1,) plots the part after the first branch of the first branch of the root branch.\nlevel = (-Inf, Inf) restrict the branching level for plotting.","category":"page"},{"location":"plotting/#Plotting-without-the-plot-recipe","page":"Plotting","title":"Plotting without the plot recipe","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"What if you don't want to use Plots.jl? You can define your own plotting functions using the internal fields of br which is of type ContResult. For example, in PyPlot, Gadfly, GR, etc., you can do the following to plot the branch (like the plot recipe plot(br, vars = (:param, :x))):","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"plot(br.branch.param, br.branch.x)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"You can also have access to the stability of the points by using br.stable. More information concerning the fields can be found in ContResult. For example, you can change the color depending on the stability:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"col = [stb ? :green : :red for stb in br.stable]\nplot(br.param, br.x, color=col)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"You can also plot the spectrum at a specific continuation step::Int by calling","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"# get the eigenvalues\neigvals = br.eig[step].eigenvals\n\n# plot them in the complex plane\nscatter(real.(eigvals), imag.(eigvals))","category":"page"},{"location":"plotting/#Standard-plots-using-the-Makie.jl-[Experimental]","page":"Plotting","title":"Standard plots using the Makie.jl [Experimental]","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Plotting is also provided by calling recipes to Makie.jl. It means that to plot a branch br, you just need to call","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"#]add GLMakie # You need to install GLMakie.jl before your first time using it!\nusing GLMakie\nBifurcationKit.plot(br)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"The keyword arguments to BifurcationKit.plot are the same as decribed above in the page. You can also combine diagrams with BifurcationKit.plot(br1, br2) or use BifurcationKit.plot!(ax, br) to add a branch to an existing plot.","category":"page"},{"location":"plotting/#Example","page":"Plotting","title":"Example","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"using Revise, GLMakie, BifurcationKit\nMakie.inline!(true)\nq = 1/0\nk = 2\nF(x, p) = (@. p + x - x^(k+1)/(k+1))\nprob = BifurcationProblem(F, [0.8], 1., (@lens _); record_from_solution = (x,p) -> x[1])\nopts = ContinuationPar(dsmax = 0.1, dsmin = 1e-3, ds = -0.001, p_min = -1., p_max = 1.)\nbr = continuation(prob, PALC(), opts)\nBifurcationKit.plot(br)","category":"page"},{"location":"#MultiParamContinuation.jl","page":"Home","title":"MultiParamContinuation.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This Julia package aims at performing multi parameter continuation of possibly large dimensional equations F(u par) = 0 where Fmathbb R^ntimes mathbb R^partomathbb R^m by taking advantage of iterative methods, dense / sparse formulation and specific hardwares (e.g. GPU).","category":"page"},{"location":"","page":"Home","title":"Home","text":"It incorporates a continuation algorithm [Henderson][Dankowicz] based on a Newton method to correct a predictor step and a Matrix-Free/Dense/Sparse eigensolver can be used to compute stability and bifurcation points.","category":"page"},{"location":"#Limitations","page":"Home","title":"Limitations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"As this is early work, the following limitations need to be addressed.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It is partially optimized for speed (allocations, static arrays, etc)\nIt is not suitable as is for large scale problems although it is very simple to address this. Note that the interface for jacobian free computation has yet to been pushed.\nIt only computes 2d manifolds for now, i.e. n=m+2\nIt allows loose detection of continuous events (no bisection)\nOne needs to improve interface for using BVH search tree in large dimensions.","category":"page"},{"location":"#Installation","page":"Home","title":"📦 Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install it, please run","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add MultiParamContinuation","category":"page"},{"location":"","page":"Home","title":"Home","text":"To install the bleeding edge version, please run","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add MultiParamContinuation#master","category":"page"},{"location":"#Citing-this-work","page":"Home","title":"📚 Citing this work","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use this package for your work, we ask that you cite the following paper!! Open source development strongly depends on this. It is referenced on HAL-Inria with bibtex entry CITATION.bib.","category":"page"},{"location":"#Other-softwares","page":"Home","title":"🧑‍💻 Other softwares","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are many good softwares already available.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For continuation in small dimension, there is only COCO which is very reliable and for now more general than MultiParamContinuation.jl as it can compute k-d manifolds. Of course, we have the original C++ implementation by M. Henderson Multifario.\nFor large scale problems, there is only Trilinos-LOCA","category":"page"},{"location":"","page":"Home","title":"Home","text":"In Julia, there is no other alternative to the current package.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[Henderson]: Henderson, Michael E. “Multiple Parameter Continuation: Computing Implicitly Defined k-Manifolds.” International Journal of Bifurcation and Chaos 12, no. 03 (March 2002): 451–76. https://doi.org/10.1142/S0218127402004498.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[Dankowicz]: Dankowicz, Harry, and Frank Schilder. Recipes for Continuation. Philadelphia, PA: Society for Industrial and Applied Mathematics, 2013. https://doi.org/10.1137/1.9781611972573.","category":"page"}]
}
