var documenterSearchIndex = {"docs":
[{"location":"tutorials/ode/torus/#Torus","page":"üü¢ Torus","title":"üü¢ Torus","text":"In this tutorial, we show how to cover a torus.\n\nIt is easy to encode the manifold as follows\n\nusing CairoMakie, MultiParamContinuation\nconst MPC = MultiParamContinuation\n\nfunction F(u, p)\n    x,y,z = u\n    R2 = 0.5\n    R1 = 0.8\n    return [(sqrt(x^2 + y^2) - R1)^2 + z^2 - R2^2]\nend\n\nprob = ManifoldProblem(F, [-0.05, 1.29, -0.05], nothing)\n\nshow(prob)\n\nWe now compute a covering of the manifold \n\nS = MPC.continuation(prob,\n            Henderson(np0 = 8),\n            CoveringPar(max_charts = 2000, \n                    max_steps = 16000,\n                    verbose = 0,\n                    R0 = .1,\n                    œµ = Inf,\n                    delta_angle = Inf,\n                    ))\nshow(S)\n\nYou plot the result as follows\n\nf = MPC.plotd(S; \n    draw_tangent = true, \n    draw_edges = true,\n    plot_center = false,\n    )","category":"section"},{"location":"tutorials/ode/abc/#ABC-problem","page":"üü° ABC problem","title":"üü° ABC problem","text":"The goal of this tutorial is to show how to compute a Manifold from a BifurcationProblem as function of two free parameters.\n\nusing CairoMakie\nusing BifurcationKit, MultiParamContinuation\n\nconst BK = BifurcationKit\nconst MPC = MultiParamContinuation\n\nfunction abc!(dz, z, p, t = 0)\n    (;D, B, œÉ, Œ≤, Œ±) = p\n    u1, u2, u3 = z\n    dz[1] = -u1 + D*(1 - u1)*exp(u3)\n    dz[2] = -u2 + D*(1 - u1)*exp(u3) - D*œÉ*u2*exp(u3)\n    dz[3] = -u3 - Œ≤*u3 + D*B*(1 - u1)*exp(u3) + D*B*Œ±*œÉ*u2*exp(u3)\n    dz\nend\n\npar_abc = (D = 0.11, B = 8., Œ± = 1., œÉ = 0.04, Œ≤ = 1.56)\nz0 = [1., 0., 0. ]\nprob_bk = BifurcationProblem(abc!, z0, par_abc, (@optic _.D), \n        record_from_solution = (x, p; k...) -> (u3 = x[3], u1 = x[1], u2 = x[2]),)\n\nopts_br = ContinuationPar(p_max = 1.5, n_inversion = 8, nev = 3)\nbr = BK.continuation(prob_bk, PALC(), opts_br; normC = norminf)\n\nWe can also compute the stationary points as function of two free parameters:\n\nprob = MPC.ManifoldProblem_BK(\n                        prob_bk, br.sol[1].x, (@optic _.D), (@optic _.Œ≤);\n                        record_from_solution = (X, p; k...) -> begin\n                            return (Œ≤ = X[end], D = X[end-1], u3 = X[3])\n                        end,\n                        finalize_solution = (X,p) -> begin\n                            D = X[end-1]\n                            Œ≤ = X[end]\n                            keep = (0.01 <= D <= 0.5) && (1.5 <= Œ≤ <= 1.65)\n                            return keep\n                        end,\n                        )\n\nS_eq = @time MPC.continuation(prob,\n                        Henderson(np0 = 3,\n                                    Œ∏min = 0.001,\n                                    # use_curvature = true,\n                                    use_tree = true,\n                                  ),\n                        CoveringPar(max_charts = 20000,\n                                max_steps = 10000,\n                                verbose = 0,\n                                newton_options = NewtonPar(tol = 1e-10),\n                                R0 = .04,\n                                œµ = 0.1,\n                                delta_angle = 10.15,\n                                ))\n\nYou can plot the data as follows\n\nfunction plot_data(S; k...)\n    fig = Figure()\n    ax = Axis3(fig[1,1], zlabel = \"Œ≤\", xlabel = \"u‚ÇÉ\", ylabel = \"D\", title = \"$(length(S)) charts\")\n    plot_data!(ax, S; k...)\n    fig, ax\nend\n\nfunction plot_data!(ax, S; ind = (3,4,5),ind_col = 1, fil=x->true, cols = [real(c.index) for c in filter(x -> fil(x.u), S.atlas)])\n    pts = mapreduce(c->[c.u[ind[1]], c.u[ind[2]], c.u[ind[3]]]', vcat, filter(x -> fil(x.u), S.atlas))\n    hm = scatter!(ax, pts, color = cols)\nend\n\nf, ax = plot_data(S_eq)\nf\n\nor using the function MPC.plotd\n\nfig = Figure()\nax = Axis3(fig[1,1], zlabel = \"Œ≤\", xlabel = \"u‚ÇÉ\", ylabel = \"D\", title = \"$(length(S_eq)) charts\")\nMPC.plotd(ax, S_eq; \n    draw_tangent = true, \n    plot_center = false,\n    draw_edges = false,\n    ind_plot = (3,4,5)\n    )\nfig","category":"section"},{"location":"tutorials/ode/abc/#Surface-of-Hopf-points-as-function-of-3-parameters","page":"üü° ABC problem","title":"Surface of Hopf points as function of 3 parameters","text":"opts_cover = CoveringPar(max_charts = 1000,\n    max_steps = 1000,\n    # verbose = 1,\n    newton_options = NewtonPar(tol = 1e-11, verbose = false),\n    R0 = .1,\n    œµ = 0.15,\n    )\n\natlas_hopf = @time MPC.continuation(deepcopy(br), 1, \n    (@optic _.Œ±), (@optic _.Œ≤), \n    opts_cover;\n    alg = Henderson(np0 = 5,\n                Œ∏min = 0.001,\n                use_curvature = false,\n                use_tree = true,\n            ),\n    )\n\nfig = Figure()\nax = Axis3(fig[1,1], zlabel = \"Œ≤\", xlabel = \"D\", ylabel = \"Œ±\", title = \"$(length(atlas_hopf)) charts\")\n\nMPC.plotd(ax, atlas_hopf; \n    draw_tangent = true, \n    plot_center = false,\n    draw_edges = true,\n    ind_plot = (4, 5, 6)\n    )\nfig","category":"section"},{"location":"tutorials/ode/abc/#Surface-of-Periodic-orbits-as-function-of-2-parameters","page":"üü° ABC problem","title":"Surface of Periodic orbits as function of 2 parameters","text":"We trace the curve of periodic orbits from a Hopf point. Note that this can be improved a lot using the linear solver BK.COPBLS, we do not do it here to simplify the code.\n\n argspo = (record_from_solution = (x, p; k...) -> begin\n                xtt = BK.get_periodic_orbit(p.prob, x, p.p)\n                return (max = maximum(xtt[3,:]), min = minimum(xtt[3,:]), period = x[end])\n            end,\n    plot_solution = (ax, x, p; k...) -> begin\n        xtt = BK.get_periodic_orbit(p.prob, x, p.p)\n        lines!(ax, xtt.t, xtt.u[1,:]; label = \"u1\", linewidth = 2)\n        lines!(ax, xtt.t, xtt.u[2,:]; label = \"u2\")\n        BK.plot!(get(k, :ax1, nothing), br)\n    end,)\n\n# continuation parameters\nopts_po_cont = ContinuationPar(dsmax = 0.03, dsmin = 1e-4, ds = 0.0005, max_steps = 130, tol_stability = 4e-2, plot_every_step = 20)\n\nbr_po = BK.continuation(\n    br, 1, opts_po_cont,\n    PeriodicOrbitOCollProblem(50, 4; update_section_every_step = 1, jacobian = BK.DenseAnalyticalInplace());\n    Œ¥p = 0.0001,\n    argspo...,\n    normC = norminf)\n\nf, ax = BK.plot(br, br_po, branchlabel = [\"equilibria\", \"periodic orbits\"])\nxlims!(ax, (0.1,0.4))\nf\n\nWe can now compute the manifold\n\nusing LinearAlgebra\nconst coll = br_po.prob # I know! This is not very good...\n\nprob = MPC.ManifoldProblem_BK(\n                        br_po.prob, br_po.sol[1].x, (@optic _.D), (@optic _.Œ≤),\n                        record_from_solution = (X, p; k...) -> begin\n                            xtt = BK.get_periodic_orbit(coll, X[1:end-2], nothing)\n                            Max = maximum(xtt[3,:])\n                            return (u3 = Max, D = X[end-1], Œ≤ = X[end], period = X[end-2])\n                        end,\n                        finalize_solution = (X,p) -> begin\n                            D = X[end-1]\n                            Œ≤ = X[end]\n                            keep = (0.1 <= D <= 0.5) && (1.5 <= Œ≤ <= 1.65)\n                            return keep\n                        end,\n                        )\n\nS_po = @time MPC.continuation(prob,\n                        Henderson(np0 = 6,\n                                  Œ∏min = 0.001,\n                                  use_curvature = true,\n                                  ),\n                        CoveringPar(max_charts = 20000,\n                                max_steps = 200,\n                                verbose = 1,\n                                newton_options = NewtonPar(tol = 1e-10, verbose = false),\n                                R0 = .5,\n                                œµ = 0.4,\n                                delta_angle = 4pi,\n                                )\n                        )\n\nfig = Figure()\nax3 = Axis3(fig[1,1], xlabel = \"period\", ylabel = \"D\", zlabel = \"Œ≤\", title = \"PO $(length(S_po)) charts\")\npts = mapreduce(c->[c.data.period, c.data.D, c.data.Œ≤ ]', vcat, S_po.atlas)\nscatter!(ax3, pts, color = [c.data[2] for c in S_po.atlas])\nfig\n\nor\n\nfig = Figure()\nax3 = Axis3(fig[1,1], zlabel = \"Œ≤\", xlabel = \"period\", ylabel = \"D\", title = \"PO $(length(S_po)) charts\")\nMPC.plotd(ax3, S_po; \n    draw_tangent = true, \n    plot_center = false,\n    draw_edges = false,\n    ind_plot = (604,605,606)\n    )\nfig","category":"section"},{"location":"henderson/#Henderson-covering-manifold","page":"Henderson","title":"Henderson covering manifold","text":"Pages = [\"henderson.md\"]\nDepth = 3\n\nWe want to approximte \n\nmathcal M=leftu in mathbbR^n mid F(u)=0 quad F mathbbR^n rightarrow mathbbR^mright","category":"section"},{"location":"henderson/#Tangent-space-basis","page":"Henderson","title":"Tangent space basis","text":"We get an orthonormal basis of the tangent space at a space u_iinmathcal M by looking for a ntimes 2 matrix Phi_i such that \n\nbinomF_uleft(u_iright)Phi_i^T Phi_i=binom0I","category":"section"},{"location":"henderson/#Projecting-from-the-tangent-space","page":"Henderson","title":"Projecting from the tangent space","text":"A point on mathcal M corresponding to a vector s in the tangent space is solution to:\n\nbeginaligned\nFleft(u_i(s)right)  =0 \nPhi_i^Tleft(u_i(s)-left(u_i+Phi_i sright)right)  =0\nendaligned\n\nHence, u_i+Phi_i s is projected on mathcal M at the point u_i.","category":"section"},{"location":"henderson/#Algorithm","page":"Henderson","title":"Algorithm","text":"The algorithm Henderson described in [Henderson] covers a manifold mathcal M with local approximations of the manifold which are called charts. It starts with a point u_0 on mathcal M, a k-d ball B_R_0(0) on the tangent space at u_0, a convex polygon mathbb P on the tangent space. \n\nA chart C is defined as C = (u_0B_R_0(0) mathbb P). R_0 is the radius of validity of the chart meaning that the distance of the ball (on the tangent) space to the manifold mathcal M is less than a prescribed value epsilon.\n\nThe algorithm selects a set of charts (C_i)_i which covers mathcal M meaning that the union of the projection of the balls B_R_i(0) on the manifold covers (parts of) the manifold.\n\nCharts intersect if the projection of their validity balls on the manifold intersect. Their polygons are then trimmed in order to remove the intersection which can move some vertices inside the validity ball.\n\nThe algorithm ends when all the charts have their polygon inside the validity ball.\n\nIn the case this is not the case, the algorithm selects such a chart C = (u_0B_R_0(0) mathbb P) and define a new chart C_new by using an exterior vertex s of mathbb P. s is projected on the manifold mathcal M, its tangent space is computed, its radius is R_0 and the new polygon is the cube. The new chart C_new is then intersected with the previously computed charts.","category":"section"},{"location":"henderson/#Search-tree","page":"Henderson","title":"Search tree","text":"When the projection is very quickly computed, the limiting factor of the algorithm becomes finding the neighbors of a chart. This can become slow when the atlas is large giving a quadratic N^2 complexity in total. This can be alleviated by using a BVH tree to obtain a Nlog N complexity as explained in [Henderson]. This is implemented in MultiParamContinuation.jl and can be set up in the struct Henderson, see its associated doc.","category":"section"},{"location":"henderson/#References","page":"Henderson","title":"References","text":"[Henderson]: Henderson, Michael E. ‚ÄúMultiple Parameter Continuation: Computing Implicitly Defined k-Manifolds.‚Äù International Journal of Bifurcation and Chaos 12, no. 03 (March 2002): 451‚Äì76. https://doi.org/10.1142/S0218127402004498.\n\n[Dankowicz]: Dankowicz, Harry, and Frank Schilder. Recipes for Continuation. Philadelphia, PA: Society for Industrial and Applied Mathematics, 2013. https://doi.org/10.1137/1.9781611972573.","category":"section"},{"location":"library/#Library","page":"Library","title":"Library","text":"Pages = [\"library.md\"]\nDepth = 3","category":"section"},{"location":"library/#Parameters","page":"Library","title":"Parameters","text":"","category":"section"},{"location":"library/#Results","page":"Library","title":"Results","text":"","category":"section"},{"location":"library/#Problems","page":"Library","title":"Problems","text":"","category":"section"},{"location":"library/#Continuation-algorithms","page":"Library","title":"Continuation algorithms","text":"","category":"section"},{"location":"library/#Continuation-methods","page":"Library","title":"Continuation methods","text":"","category":"section"},{"location":"library/#bouding-space","page":"Library","title":"Bounding functions","text":"","category":"section"},{"location":"library/#MultiParamContinuation.CoveringPar","page":"Library","title":"MultiParamContinuation.CoveringPar","text":"Parameters for the covering algorithm(s).\n\nFields\n\nœµ::Any: Maximum distance between the tangent plane and the manifold. Default: 0.1\nR0::Any: Initial radius of validity. Default: 0.1\nRmin::Any: [Internal] Minimal radius of polyhedra. Default: 0.001\ndelta_angle::Any: Maximum angle difference between charts' tangent spaces in radians. Default: 2œÄ\nmax_charts::UInt64: Maximum number of charts. Default: 100\nmax_steps::UInt64: Maximum number of continuation steps. Because of mesh adaptation or failure, the number of computed charts is less or equal than max_steps. Default: 1000\nverbose::Int64: Verbose mode, belongs to {0,1,2}. verbose = 0 prints nothing. verbose = 1 prints the charts, verbose = 2 print the intersection of the charts. Default: false\nnewton_options::Any: Newton options. Default: NonLinearSolveSpec()\nsolver_bls::Any: Bordered Linear Solver Default: nothing\ndotmin::Any: [Internal]. Default: 0.2\n\n\n\n\n\n","category":"type"},{"location":"library/#MultiParamContinuation.Chart","page":"Library","title":"MultiParamContinuation.Chart","text":"mutable struct Chart{Tu, Ttg, Tr, Tp, Tin, Td, Teve, Tl}\n\nStructure to define a chart, that is a local system of coordinates which parametrizes a small patch of the manifold.\n\nFields\n\nu::Any\nŒ¶::Any\nR::Any: Radius for region of validity (Ball).\nP::Any: Polyhedron. Represents the domain of the solution manifold covered by this chart.\ninside_ball::Any: Array of booleans to check if the vertices in P are inside the ball of validity\ninterior::Bool: Is the polygon inside the validity ball?\nindex::Int64\ndata::Any\nevent_values::Any\nlabel::Any\nneighbors::Vector{Int64}: [Internal] list of direct neighbors in the atlas\n\nMethods\n\ndo_intersect(c1, c2)::Bool whether the charts intersect\n\n\n\n\n\n","category":"type"},{"location":"library/#MultiParamContinuation.Atlas","page":"Library","title":"MultiParamContinuation.Atlas","text":"struct Atlas{dim, Tc, Talg, Ttree}\n\nAtlas of charts which represents a manifold.\n\nFields\n\natlas::Vector: List of Charts\nBList::Vector: [Internal] Boundary list of charts\nalg::Any: Algorithm, for example: Henderson()\ntree::Any: [Internal] Tree for neighbors search\n\nMethods\n\nadd!(a::Atlas, c::Chart)\nnew_atlas(c::Chart, alg = nothing; dim = 2)\nlength(a::Atlas) returns the number of charts\na[3] returns the 3rd chart in the atlas a, see ?Chart\n\n\n\n\n\n","category":"type"},{"location":"library/#MultiParamContinuation.ManifoldProblem","page":"Library","title":"MultiParamContinuation.ManifoldProblem","text":"struct ManifoldProblem{Tu<:(AbstractVector), Tp, TVF, Trec, Tproj, Ttangent, Tradius, Tevent, Tfinalize, Tbb, Tpc, Tupdate} <: MultiParamContinuation.AbstractManifoldProblem\n\nDefine a problem to perform multi-parameters continuation of a manifold defined as the zeros of F: R‚Åø ‚Üí R·µê with n > m >= 1.\n\nFields\n\nn::Int64: [Internal] input space dimension.\nm::Int64: [Internal] output space dimension.\nVF::Any: Equation representing the mapping F (vector field).\nu0::AbstractVector: Guess for the initial point on the manifold.\nparams::Any: Parameters passed to F\nrecordFromSolution::Any: Record a few indicators at each chart of the manifold.\nproject::Any: Function to project a point from a tangent space to the manifold. If not provided, a newton algorithm is used. The signature is project(u, par) and returns a vector of solutions.\nget_tangent::Any: Compute an orthonormal basis of the tangent space at a point u on the manifold. Return a matrix of dimension n x (n-m). The signature is get_tangent(u, par). If not provided, a dedicaded function is used.\nget_radius::Any: Get the an estimate of the curvature at a point u on the manifold. If not provided, a dedicaded function is used.\nevent_function::Any: Event function\nfinalize_solution::Any: Finalise solution. Function to accept or not the current chart. It has signature finalise(c::Chart, par)::Bool.\nproject_for_tree::Any: Function  used to project a point for the tree used to find the charts near a new point. Needs not be linear but the dimension should be at least the manifold embedding dimension.\nprob_cons::Any: [Internal] constrained problem for projecting on manifold.\nupdate!::Any: Function used to update the problem after each continuation step. The signature is update_problem!(prob, ::Atlas).\n\nConstructor\n\nManifoldProblem(F, u0, par;\n                m = length(F(u0, par)),\n                check_dim::Bool = true,\n                recordFromSolution = (u,p) -> nothing,\n                project = nothing,\n                get_radius = get_radius_default,\n                get_tangent = nothing,\n                event_function = event_default,\n                finalize_solution = finalize_default,\n                project_for_tree = project_for_tree_default\n                )\n\n\n\n\n\n","category":"type"},{"location":"library/#MultiParamContinuation.ManifoldProblemBK","page":"Library","title":"MultiParamContinuation.ManifoldProblemBK","text":"struct ManifoldProblemBK{Tu<:(AbstractVector), Tp, TVF, Trec, Tproj, Ttangent, Tradius, Tevent, Tfinalize, Tbb, Tpc, Tupdate} <: MultiParamContinuation.AbstractManifoldProblem\n\nDefine a problem to perform multi-parameters continuation of a manifold defined as the zeros of F: R‚Åø ‚Üí R·µê with n > m >= 1.\n\nFields\n\nn::Int64: [Internal] input space dimension.\nm::Int64: [Internal] output space dimension.\nVF::Any: Equation representing the mapping F (vector field).\nu0::AbstractVector: Guess for the initial point on the manifold.\nparams::Any: Parameters passed to F\nrecordFromSolution::Any: Record a few indicators at each chart of the manifold.\nproject::Any: Function to project a point from a tangent space to the manifold. If not provided, a newton algorithm is used. The signature is project(u, par) and returns a vector of solutions.\nget_tangent::Any: Compute an orthonormal basis of the tangent space at a point u on the manifold. Return a matrix of dimension n x (n-m). The signature is get_tangent(u, par). If not provided, a dedicaded function is used.\nget_radius::Any: Get the an estimate of the curvature at a point u on the manifold. If not provided, a dedicaded function is used.\nevent_function::Any: Event function\nfinalize_solution::Any: Finalise solution. Function to accept or not the current chart. It has signature finalise(c::Chart, par)::Bool.\nproject_for_tree::Any: Function  used to project a point for the tree used to find the charts near a new point. Needs not be linear but the dimension should be at least the manifold embedding dimension.\nprob_cons::Any: [Internal] constrained problem for projecting on manifold.\nupdate!::Any: Function used to update the problem after each continuation step. The signature is update_problem!(prob, ::Atlas).\n\nConstructor\n\nManifoldProblem(F, u0, par;\n                m = length(F(u0, par)),\n                check_dim::Bool = true,\n                recordFromSolution = (u,p) -> nothing,\n                project = nothing,\n                get_radius = get_radius_default,\n                get_tangent = nothing,\n                event_function = event_default,\n                finalize_solution = finalize_default,\n                project_for_tree = project_for_tree_default\n                )\n\n\n\n\n\n","category":"type"},{"location":"library/#MultiParamContinuation.Henderson","page":"Library","title":"MultiParamContinuation.Henderson","text":"struct Henderson{T} <: MultiParamContinuation.AbstractCoveringAlgorithm\n\nContinuation algorithm from [1] computing implicitly defined 2d manifolds. \n\nFields\n\nnp0::Int64: Number of initial vertices in the polyhedra on each tangent space.\nuse_curvature::Bool: Use hessian for curvature estimate.\nŒ∏max::Any: [Internal]\nŒ∏min::Any: [Internal]\nuse_tree::Bool:  Use tree to find neighbors. Useful when the number of charts is large because the complexity changes from N¬≤ to N‚ãÖlog(N).\nchildren_pre_leaf::Int64: Number of children per leaf in the tree. Control the depth of the tree.\n\nReference(s)\n\n[1] Henderson, Michael E. ‚ÄúMultiple Parameter Continuation: Computing Implicitly Defined k-Manifolds.‚Äù International Journal of Bifurcation and Chaos 12, no. 03 (March 2002): 451-76. https://doi.org/10.1142/S0218127402004498.\n\n\n\n\n\n","category":"type"},{"location":"library/#MultiParamContinuation.step!","page":"Library","title":"MultiParamContinuation.step!","text":"step!(Œ©)\n\n\nPerform one step of the continuation algorithm.\n\n\n\n\n\nstep!(Œ©, n)\n\n\nPerform n steps of the continuation algorithm.\n\n\n\n\n\n","category":"function"},{"location":"library/#MultiParamContinuation.Cube","page":"Library","title":"MultiParamContinuation.Cube","text":"Define a hypercube C of radius r.\n\nC = { u ‚àà R‚Åø | -r <= u <= r}\n\nYou can define one using \n\ncube = Cube(1)\n\nYou can test whether a point is in the cube by doing\n\ncube(rand(3))\n\n\n\n\n\n","category":"type"},{"location":"library/#MultiParamContinuation.ProductSpace","page":"Library","title":"MultiParamContinuation.ProductSpace","text":"struct ProductSpace{T<:(AbstractVector)}\n\nStructure to define a domain defined by a set of intervals\n\nFields\n\nlower::AbstractVector: lower parts of all intervals\nupper::AbstractVector: upper parts of all intervals\n\nUsage\n\nFor example, to create the domain [1,2] x [3,4], you can does\n\nspace = ProductSpace([1,3], [2,4])\n\nand test whether a point belongs to this space:\n\nspace(rand(2))\n\n\n\n\n\n","category":"type"},{"location":"tutorials/ode/sphereBK/#Sphere-based-on-BifurcationKit.jl","page":"üü¢ Sphere based on BifurcationKit.jl","title":"üü¢ Sphere based on BifurcationKit.jl","text":"In this tutorial, we show how to cover a sphere as solution of\n\nF(u) = u^2-1 = 0\n\nWe use this model as a mean to introduce the basics of MultiParamContinuation.jl based on BifurcationKit.jl.\n\nIt is easy to encode the manifold using ManifoldProblem_BK which yields a ManifoldProblemBK with BifurcationKit internals.\n\nusing CairoMakie, BifurcationKit, MultiParamContinuation\nconst MPC = MultiParamContinuation\n\nF(u,p) = [u[1]^2 + u[2]^2 + u[3]^2 - 1]\n\nprob = ManifoldProblem_BK(F, \n                    [1,0.,0.],\n                    nothing\n                        )\n\nshow(prob)\n\nWe compute a covering of the manifold: \n\nS = MPC.continuation(prob,\n            Henderson(np0 = 6),\n            CoveringPar(max_charts = 20000, \n                    max_steps = 250,\n                    # trigger the use of BifurcationKit newton solver\n                    newton_options = NewtonPar(),\n                    R0 = .2,\n                    )\n            )\nshow(S)\n\nYou can now plot the result as\n\nMPC.plotd(S; \n    draw_tangent = true, \n    plot_center = false,\n    draw_edges = true,\n    )","category":"section"},{"location":"BifProblemBK/#Manifold-problem-for-use-with-BifurcationKit","page":"BifurcationKit","title":"Manifold problem for use with BifurcationKit","text":"Pages = [\"BifProblemBK.md\"]\nDepth = 3\n\nMultiParamContinuation.jl is based on newton algorithm which relies on NonlinearSolve.jl for the implementation. One can chose to rely on BifurcationKit.jl newton method.\n\nThis can be done by calling ManifoldProblem_BK which has the same arguments as ManifoldProblem.","category":"section"},{"location":"tutorials/tutorials/#Tutorials","page":"Tutorials","title":"Tutorials","text":"Pages = [\"tutorials.md\"]\nDepth = 2\n\nThe tutorials are rated by the following scale of difficulty\n\nüü¢ basic knowledge of (numerical) bifurcation theory (following equilibria / periodic orbits)\nüü° advanced knowledge of (numerical) bifurcation theory (codim 2 bifurcations of equilibria)\nüü† high level of knowledge of (numerical) bifurcation theory (codim 2 bifurcations of periodic orbits, tweaking the methods)\nüü§ very advanced tutorial, research level","category":"section"},{"location":"tutorials/tutorials/#Small-dimension-examples","page":"Tutorials","title":"Small dimension examples","text":"Pages = [\"ode/plane.md\", \"ode/sphere.md\", \"ode/torus.md\",]\nDepth = 1","category":"section"},{"location":"tutorials/tutorials/#Examples-based-on-BifurcationKit","page":"Tutorials","title":"Examples based on BifurcationKit","text":"This tutorial relies on a BifurcationProblem to define a sphere, similarly to the above examples.\n\nPages = [\"ode/sphereBK.md\"]\nDepth = 1\n\nIn this tutorial, we continue solutions (equilibria, Hopf points, periodic orbits) as function of two free parameters:\n\nPages = [\"ode/abc.md\"]\nDepth = 1","category":"section"},{"location":"tutorials/ode/sphere/#Sphere","page":"üü¢ Sphere","title":"üü¢ Sphere","text":"Pages = [\"sphere.md\"]\nDepth = 2\n\nIn this tutorial, we show how to cover a sphere as solution of\n\nF(u) = u^2-1 = 0\n\nWe use this model as a mean to introduce the basics of MultiParamContinuation.jl.\n\nIt is easy to encode the manifold as follows\n\nusing CairoMakie, MultiParamContinuation\nconst MPC = MultiParamContinuation\n\nF(u, p) = [u[1]^2 + u[2]^2 + u[3]^2 - 1]\n\nprob = ManifoldProblem(F, \n                    [1.,0,0],\n                    nothing\n                        )\n\nshow(prob)\n\nWe now compute the covering of the manifold\n\nS = MPC.continuation(prob,\n            Henderson(),\n            CoveringPar(max_charts = 20000, \n                    max_steps = 250,\n                    verbose = 0,\n                    newton_options = NonLinearSolveSpec(;maxiters = 5),\n                    R0 = .2,\n                    )\n            )\nshow(S)\n\nYou plot the result as follows\n\nMPC.plotd(S; \n    draw_tangent = true, \n    plot_center = true,\n    draw_edges = true,\n    )","category":"section"},{"location":"tutorials/ode/plane/#[Plane](@id-plane)","page":"üü¢ Plane","title":"üü¢ Plane","text":"Pages = [\"plane.md\"]\nDepth = 3\n\nIn this tutorial, we show how to cover a plane as solution of\n\nF(u) = u_3 = 0\n\nWe use this model as a mean to introduce the basics of MultiParamContinuation.jl.\n\nIt is easy to encode the manifold as follows\n\nusing CairoMakie, MultiParamContinuation\nconst MPC = MultiParamContinuation\n\nF(u,p) = [u[3]]\n\nprob = ManifoldProblem(F, [.0,0.,0.], nothing;\n                        # we pass a function to provide the tangent space\n                        # with an analytical formula\n                        get_tangent = (u,p) -> [1 0; 0 1; 0 0],\n                        # restrict computations to hypercube    \n                        finalize_solution = Cube(0.5)\n                        )\n\nshow(prob)\n\nWe now compute a covering of the manifold.\n\nS = MPC.continuation(prob,\n            Henderson(np0 = 4),\n            CoveringPar(max_charts = 20000, \n                    max_steps = 100,\n                    verbose = 0,\n                    R0 = .1,\n                    ))\nshow(S)\n\nYou plot the result as follows\n\nMPC.plotd(S; \n    draw_tangent = true, \n    plot_center = true,\n    draw_edges = true,\n    )\n\nIt is sometimes useful to have access to more information, and for example plot in 2d:\n\nMPC.plot2d(S; \n    draw_circle = true,\n    plot_center = true,\n    put_ids = true,\n    ind_plot = [1,2])","category":"section"},{"location":"BifProblem/#Manifold-problems","page":"Manifold Problems","title":"Manifold problems","text":"Pages = [\"BifProblem.md\"]\nDepth = 3\n\nThe idea behind MultiParamContinuation is to compute immersed manifolds mathcal M in memory limited environments, the manifold being defined as (parts) of the zeros of \n\nFmathbb R^ntimes mathbb R^partomathbb R^m","category":"section"},{"location":"BifProblem/#Generic-manifold-problem","page":"Manifold Problems","title":"Generic manifold problem","text":"ManifoldProblem is the basic / generic structure for encoding a bifurcation problem ; it holds the following fields:\n\nthe vector field\nan initial guess\na set of parameters\n\nas well as user defined functions for \n\nrecording (record_from_solution) indicators about the solution when this one is too large to be saved at every continuation step.\n\nand some other that we described below. A detailed account for the struct is ManifoldProblem.\n\ntip: Tutorial\nThe Plane tutorial provides an example where these arguments are used in situation.","category":"section"},{"location":"BifProblem/#Basic-example","page":"Manifold Problems","title":"Basic example","text":"using MultiParamContinuation\n\nF(u,p) = [u[3]]\n\nprob = ManifoldProblem(F, [0,0,0.], nothing)","category":"section"},{"location":"BifProblem/#Projection-function","page":"Manifold Problems","title":"Projection function","text":"You can pass your own projection function which takes a point u_guessin mathbb R^n and project it on mathcal M. For example, in the case of the plane F(u,p) = u[3], we could use:\n\nprob = ManifoldProblem(F, [0,0,0.], nothing;\n                        project = (u_g,p) -> begin\n                        \t\tu = copy(u_g)\n                        \t\tu[3] = 0\n                        \t\treturn u\n                        end,\n                        )","category":"section"},{"location":"BifProblem/#Tangent-function","page":"Manifold Problems","title":"Tangent function","text":"You can pass your own tangent function which returns an orthonormal basis of the tangent space at point u. For example, in the case of the plane F(u,p) = u[3], we could use:\n\nprob = ManifoldProblem(F, [0,0,0.], nothing;\n                        get_tangent = (u,p) -> [1 0; 0 1; 0 0],\n                        )","category":"section"},{"location":"BifProblem/#Finalizing-the-solution","page":"Manifold Problems","title":"Finalizing the solution","text":"You can pass a finalizer function which returns a boolean. This boolean is used to discard or not the current chart. This can be used to restrict the manifold to a given bounding box.\n\nYou can have a look at bounding space for predefined finalizer functions for simple spaces.\n\nprob = ManifoldProblem(F, [0,0,0.], nothing;\n                        finalize_solution = (c::Chart, p) -> true\n                        )","category":"section"},{"location":"plotting/#Plotting","page":"Plotting","title":"Plotting","text":"Pages = [\"plotting.md\"]\nDepth = 3","category":"section"},{"location":"plotting/#Standard-plots-using-the-plot-recipe-from-Plots.jl","page":"Plotting","title":"Standard plots using the plot recipe from Plots.jl","text":"Plotting is provided by calling recipes to Plots.jl. It means that to plot a branch br, you just need to call\n\n#]add Plots # You need to install Plots.jl before your first time using it!\nusing Plots\nplot(br)\n\nwhere br is a branch computed after a call to br = continuation(...). Plots can be customized using all the keyword arguments provided by Plots.jl. For example, we can change the plotting backend to the GR package and put a title on the plot by doing:\n\ngr()\nplot!(br, title = \"I have a branch!\")\n\nor you can use a scatter plot\n\nscatter(br)\n\nThen to save the plot, use savefig, for example:\n\nsavefig(\"myplot.png\")","category":"section"},{"location":"plotting/#Specific-plotting-keyword-arguments","page":"Plotting","title":"Specific plotting keyword arguments","text":"The available arguments specific to our plotting methods are\n\nplotfold = true: plot the fold points with black dots\nputspecialptlegend = true: display the legend corresponding to the bifurcation points\nvars = nothing: see below\nplotstability = true: display the stability of the branch\nplotspecialpoints = true: plot the special (bifurcation) points on the branch\nbranchlabel = \"fold branch\": assign label to a branch which is printed in the legend\nlinewidthunstable: set the linewidth for the unstable part of the branch\nlinewidthstable: set the linewidth for the stable part of the branch\nplotcirclesbif = false use circles to plot bifurcation points\napplytoX = identity apply transformation applytoX to x-axis\napplytoY = identity apply transformation applytoY to y-axis\n\nIf you have several branches br1, br2, you can plot them in the same figure by doing\n\nplot(br1, br2)\n\nin place of\n\nplot(br1)\nplot!(br2)\n\nwarn: Plot of bifurcation points\nThe bifurcation points for which the bisection was successful are indicated with circles and with squares otherwise.\n\nNote that the plot recipes use the parameter axis as xlabel, and the passed variable as ylabel.","category":"section"},{"location":"plotting/#Choosing-Variables","page":"Plotting","title":"Choosing Variables","text":"You can select which variables to plot using the keyword argument vars, for example:\n\nplot(br, vars = (:param, :x))\n\nThe available symbols are :x, :param, :itnewton, :itlinear, :ds, :Œ∏, :n_unstable, :n_imag, :stable, :step,... and:\n\nx if record_from_solution (see continuation) returns a Number.\nx1, x2,... if record_from_solution returns a Tuple.\nthe keys of the NamedTuple returned by record_from_solution.\n\nThe available symbols are provided by calling propertynames(br.branch).","category":"section"},{"location":"plotting/#Plotting-bifurcation-diagrams","page":"Plotting","title":"Plotting bifurcation diagrams","text":"To do this, you just need to call\n\nplot(diagram)\n\nwhere diagram is a branch computed after a call to diagram = bifurcationdiagram(...). You can use the keywords provided by Plots.jl and the different backends. You can thus call scatter(diagram). In addition to the options for plotting branches (see above), there are specific arguments available for bifurcation diagrams\n\ncode specify the part of the bifurcation diagram to plot. For example code = (1,1,) plots the part after the first branch of the first branch of the root branch.\nlevel = (-Inf, Inf) restrict the branching level for plotting.","category":"section"},{"location":"plotting/#Plotting-without-the-plot-recipe","page":"Plotting","title":"Plotting without the plot recipe","text":"What if you don't want to use Plots.jl? You can define your own plotting functions using the internal fields of br which is of type ContResult. For example, in PyPlot, Gadfly, GR, etc., you can do the following to plot the branch (like the plot recipe plot(br, vars = (:param, :x))):\n\nplot(br.branch.param, br.branch.x)\n\nYou can also have access to the stability of the points by using br.stable. More information concerning the fields can be found in ContResult. For example, you can change the color depending on the stability:\n\ncol = [stb ? :green : :red for stb in br.stable]\nplot(br.param, br.x, color=col)\n\nYou can also plot the spectrum at a specific continuation step::Int by calling\n\n# get the eigenvalues\neigvals = br.eig[step].eigenvals\n\n# plot them in the complex plane\nscatter(real.(eigvals), imag.(eigvals))","category":"section"},{"location":"plotting/#Standard-plots-using-the-Makie.jl-[Experimental]","page":"Plotting","title":"Standard plots using the Makie.jl [Experimental]","text":"Plotting is also provided by calling recipes to Makie.jl. It means that to plot a branch br, you just need to call\n\n#]add GLMakie # You need to install GLMakie.jl before your first time using it!\nusing GLMakie\nBifurcationKit.plot(br)\n\nThe keyword arguments to BifurcationKit.plot are the same as decribed above in the page. You can also combine diagrams with BifurcationKit.plot(br1, br2) or use BifurcationKit.plot!(ax, br) to add a branch to an existing plot.","category":"section"},{"location":"plotting/#Example","page":"Plotting","title":"Example","text":"using Revise, GLMakie, BifurcationKit\nMakie.inline!(true)\nq = 1/0\nk = 2\nF(x, p) = (@. p + x - x^(k+1)/(k+1))\nprob = BifurcationProblem(F, [0.8], 1., (@lens _); record_from_solution = (x,p) -> x[1])\nopts = ContinuationPar(dsmax = 0.1, dsmin = 1e-3, ds = -0.001, p_min = -1., p_max = 1.)\nbr = continuation(prob, PALC(), opts)\nBifurcationKit.plot(br)","category":"section"},{"location":"#MultiParamContinuation.jl","page":"Home","title":"MultiParamContinuation.jl","text":"This Julia package aims at performing multi parameter continuation of possibly large dimensional equations F(u par) = 0 where Fmathbb R^ntimes mathbb R^partomathbb R^m by taking advantage of iterative methods, dense / sparse formulation and specific hardwares (e.g. GPU).\n\nIt incorporates a continuation algorithm [Henderson][Dankowicz] based on a Newton method to correct a predictor step and a Matrix-Free/Dense/Sparse eigensolver can be used to compute stability and bifurcation points.","category":"section"},{"location":"#Limitations","page":"Home","title":"Limitations","text":"The following limitations need to be addressed.\n\nIt is partially optimized for speed (allocations, static arrays, etc).\nIt is not suitable as is for large scale problems apart from sparse ones although it is very simple to address this. Note that the interface for jacobian free computation has yet to been pushed.\nIt only computes 2d manifolds for now, i.e. n=m+2.\nIt allows loose detection of continuous events (no bisection).\nOne needs to improve interface for using BVH search tree in large dimensions.","category":"section"},{"location":"#Installation","page":"Home","title":"üì¶ Installation","text":"To install it, please run\n\n] add MultiParamContinuation\n\nTo install the bleeding edge version, please run\n\n] add MultiParamContinuation#master","category":"section"},{"location":"#Citing-this-work","page":"Home","title":"üìö Citing this work","text":"If you use this package for your work, we ask that you cite the following paper!! Open source development strongly depends on this. It is referenced on HAL-Inria with bibtex entry CITATION.bib.","category":"section"},{"location":"#Other-softwares","page":"Home","title":"üßë‚Äçüíª Other softwares","text":"There are many good softwares already available.\n\nFor continuation in small dimension, there is only COCO which is very reliable and for now more general than MultiParamContinuation.jl as it can compute k-d manifolds. Of course, we have the original C++ implementation by M. Henderson Multifario.\nFor large scale problems, there is only Trilinos-LOCA\n\nIn Julia, there is no other alternative to the current package.","category":"section"},{"location":"#References","page":"Home","title":"References","text":"[Henderson]: Henderson, Michael E. ‚ÄúMultiple Parameter Continuation: Computing Implicitly Defined k-Manifolds.‚Äù International Journal of Bifurcation and Chaos 12, no. 03 (March 2002): 451‚Äì76. https://doi.org/10.1142/S0218127402004498.\n\n[Dankowicz]: Dankowicz, Harry, and Frank Schilder. Recipes for Continuation. Philadelphia, PA: Society for Industrial and Applied Mathematics, 2013. https://doi.org/10.1137/1.9781611972573.","category":"section"}]
}
